(ns eopl.parser
  "We will encode the program text as a Lisp to avoid writing a scanner as
  this is not the focus of this project"
  (:refer-clojure :exclude [list cons]))

(defn parse
  "parse is passed a element 'elt' as generated by read-string on the program text"
  [elt]
  (cond (number? elt) {:op :lit-exp
                       :datum elt}
        (symbol? elt) {:op :var-exp
                       :id elt}
        (list? elt) 
        (let [rator (first elt)
              rands (rest elt)]
          (cond (= rator '+) {:op :primapp-exp
                              :prim :+
                              :rands (map parse rands)}
                (= rator '-) {:op :primapp-exp
                              :prim :-
                              :rands (map parse rands)}
                (= rator '*) {:op :primapp-exp
                              :prim :*
                              :rands (map parse rands)}
                (= rator 'add1) {:op :primapp-exp
                                 :prim :add1
                                 :rands (map parse rands)}
                (= rator 'sub1) {:op :primapp-exp
                                 :prim :sub1
                                 :rands (map parse rands)}
                (= rator 'list) {:op :primapp-exp
                                 :prim :list
                                 :rands (map parse rands)}
                (= rator 'cons) {:op :primapp-exp
                                 :prim :cons
                                 :rands (map parse rands)}
                (= rator 'cdr) {:op :primapp-exp
                                :prim :cdr
                                :rands (map parse rands)}
                (= rator 'car) {:op :primapp-exp
                                :prim :car
                                :rands (map parse rands)}
                (= rator 'if) (let [parsed-rands (map parse rands)]
                                {:op :if-exp
                                 :test-exp (first parsed-rands)
                                 :true-exp (second parsed-rands)
                                 :false-exp (nth parsed-rands 2)})
                (= rator 'let) (let [bindings (first rands)
                                     body (second rands)
                                     rands (map second bindings)]
                                 {:op :let-exp
                                  :ids (map first bindings)
                                  :rands (map #(parse (second %)) bindings)
                                  :body (parse body)})
                (= rator 'unpack) {:op :unpack-exp
                                   :ids (first rands)
                                   :exp (parse (second rands))
                                   :body (parse (nth rands 2))}
                :else (throw (Exception. (str "Unknown rator: " rator)))))
        :else (throw (Exception. (str "Invalid element: " elt)))))
  
